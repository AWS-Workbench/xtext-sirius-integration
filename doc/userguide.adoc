= Xtext / Sirius Integration User Guide
Niko Stotz <niko.stotz@altran.com>
:toc:
:toclevels: 5
:miscellaneous.tabsize: 2
:tabsize: 2
:icons: font
:sectnum: 
:sectnums: 
:experimental:
:commandkey: &#8984;
:m1keys: Ctrl]/kbd:[{commandkey}
:source-highlighter: pygments
:prewrap!:
:docinfo2:

This plugin enables https://www.eclipse.org/Xtext/[Xtext] editors to be used as direct editor for https://www.eclipse.org/sirius/[Sirius] diagram elements or Sirius property widgets.

This document describes to users (i.e. developers using the Xtext editors in their project) how to work with the Xtext / Sirius integration.

== Terminology

Sirius element::
	Contents of the *.odesign model describing the Sirius application.
	
diagram element::
	Sirius element describing something inside a diagram.
	
property element::
	Sirius element describing something inside the properties view.
	
semantic element::
	EObject of a model the end-user is working with.
	
identifier::
	String entered in the "Id" field of a Sirius element, unique within the Sirius application.
	
direct editor::
	Editor that is displayed inside the diagram if the end-user double-clicks a diagram element or presses F2 while the diagram element is focused.

widget::
	One entry field for a property element inside the properties view.

newline::
	Platform-dependent invisible character(s) denoting the end of one line of text and the start of a new line of text.
	
multi-line::
	Text entry field that shows (potentially) more than one line, and allows the add and remove newlines. Opposite of single-line.
	
single-line::
	Text entry field that shows only one line, and does not allow to add a newline. Opposite of multi-line.
	
injector::
	Google Guice injector completely configured for an Xtext language.
	
feature::
	Instance of Ecore EStructuralFeature describing a part of a semantic element.
	

== Overview
This plugin provides extension points to replace regular text entry fields with Xtext-enabled text entry fields.

Xtext-enabled editors provide the usual Xtext features: syntax highlighting, auto completion, validation, etc.

The Xtext language does not need to be modified to be used in the editor (except for <<specialEditGrammar, fixing an Xtext bug>>).

The text entry fields can be placed 

* either inside a Sirius diagram (direct editors; <<directEdit, directEdit>>)
* or in the Sirius properties view (widgets; <<property, property>>). In this case, we may customize
** the SWT widget style flags (<<widgetStyle, widgetStyle>>),
** and the SWT GridLayoutData (<<layoutData, layoutData>>).

The contents of the editors can be retrieved 

* either from a semantic element of a model that's used as input to the diagram (<<model, model>>),
* or from a String feature of a semantic element (<<value, value>>). In this case, we may supply additional information if we wanted to edit an incomplete model:
** text (hidden from the end-user) to be pre-pended (<<prefixText-suffixText, prefixText>>),
** text (hidden from the end-user) to be appended (<<prefixText-suffixText, suffixText>>).

For _model_-based _directEdit_ editors, the contents can be limited to a set of features (<<editableFeatures, editableFeatures>>).
If the model element is an edge, the position of the affected label must be set (<<edgeLabelPosition, edgeLabelPosition>>).

An editor can display

* either single-line contents (<<singleLine-multiLine, singleLine>>),
* or multi-line contents (<<singleLine-multiLine, multiLine>>).

For all editors, we need to provide

* an identifier to link to the affected Sirius element (<<identifier, identifier>>),
* and an injector to access the Xtext language to use (<<injector, injector>>).
	

All of this can be summarized in one table:

[options="autowidth"]
|====
|	^.<| *<<property, property>>*	2+^.<| *<<directEdit, directEdit>>*	| *add. info footnoteref:[info]*

.2+.^| *<<model, model>>*	| <<singleLine-multiLine, singleLine>>	| <<singleLine-multiLine, singleLine>>	.2+.^| _<<editableFeatures, editableFeatures>>, <<edgeLabelPosition, edgeLabelPosition>>_	|
	| <<singleLine-multiLine, multiLine>>	| <<singleLine-multiLine, multiLine>> |

.2+.^| *<<value, value>>*	| <<singleLine-multiLine, singleLine>>	2+| <<singleLine-multiLine, singleLine>>	.2+.^| _<<prefixText-suffixText, prefixText>>, <<prefixText-suffixText, suffixText>>_
	| <<singleLine-multiLine, multiLine>>	2+| <<singleLine-multiLine, multiLine>> 

| *add. info footnoteref:[info]*	| _<<widgetStyle, widgetStyle>>, <<layoutData, layoutData>>_ 2+| 	| *for all:* _<<identifier, identifier>>, <<injector, injector>>_
|====


As an advanced capability, the editor might use a <<specialEditGrammar, different grammar>> (a.k.a. Xtext language) for editing model contents than the one used for serialization.

== Examples
	
.plugin.xml
[source,xml]
----
<extension point="com.altran.general.integration.xtextsirius.xtextDirectEdit">
	<xtextDirectEditModel      <1>
		configClass="org.eclipse.xtext.example.fowlerdsl.viewpoint.xtextsirius.editPart.EditPartConfigurationFowlerdsl"
		identifier="EventNode"/>
	<xtextDirectEditModel      <2>
		configClass="org.eclipse.xtext.example.fowlerdsl.viewpoint.xtextsirius.editPart.EditPartConfigurationFowlerdsl"
		identifier="TransitionEdge">
		<editableFeature name="event"/>
		<editableFeature name="guard"/>
	</xtextDirectEditModel>
	<xtextDirectEditValue      <3>
		configClass="org.eclipse.xtext.example.fowlerdsl.viewpoint.xtextsirius.editPart.EditPartConfigurationHtml"
		identifier="description"
		multiLine="true"
		prefixText="&lt;html&gt;&lt;head&gt;&lt;title&gt;t&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"
		suffixText="&lt;/body&gt;&lt;/html&gt;"/>
</extension>

<extension point="com.altran.general.integration.xtextsirius.xtextProperty">
	<xtextPropertyModel        <4>
		configClass="org.eclipse.xtext.example.fowlerdsl.viewpoint.xtextsirius.eef.EefConfigurationFowlerdsl"
		identifier="EventGuardId"/>
	<xtextPropertyValue        <5>
		configClass="org.eclipse.xtext.example.fowlerdsl.viewpoint.xtextsirius.eef.EefConfigurationHtml"
		identifier="StateDescriptionId"
		multiLine="true"
		prefixText="&lt;html&gt;&lt;head&gt;&lt;title&gt;t&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"
		suffixText="&lt;/body&gt;&lt;/html&gt;"/>
</extension>
----

1. Single-line direct editor of all features of _Event_ instance of Sirius element `EventNode` with the injector supplied by `EditPartConfigurationFowlerdsl`. 
Persisted to itself because _SelfEdit.Set.featureName_ is empty.
+
.Event Label (note it does not show the code)
image:images/eventLabel.png[]
+
.Event Editor
image:images/eventEditor.png[]

2. Single-line direct editor of features `{event, guard}` for the center label of _Transition_ instance of Sirius element `TransitionEdge` with the injector supplied by `EditPartConfigurationFowlerdsl`.
Persisted to itself because _SelfEdit.Set.featureName_ is empty.
+
.Transition Label (note it does have additional text at the end)
image:images/transitionLabel.png[]
+
.Transition Editor (note the target of the transition cannot be edited)
image:images/transitionEditor.png[]

3. Multi-line direct editor of _description_ feature of _State_ instance of Sirius element `description` with the injector supplied by `EditPartConfigurationHtml`.
The attribute value will be prefixed by an HTML header and suffixed by an HTML footer.
Persisted to _State.description_ because of _DescriptionEdit.Set.featureName=description_.
+
.Description Label (note it does have additional text at the front)
image:images/descriptionLabel.png[]
+
.Description Editor
image:images/descriptionEditor.png[]

4. Single-line property editor of _guard_ feature of _Event_ instance of Sirius element `EventGuardId` with the injector supplied by `EefConfigurationFowlerdsl`.
Persisted to _Event.guard_ because of _EventGuardId.Set.featureName=guard_.
+
.Event Guard Property Editor
image:images/guardProperty.png[]

5. Multi-line property editor of _description_ feature of _State_ instance of Sirius element `StateDescriptionId` with the injector supplied by `EefConfigurationHtml`.
The attribute value will be prefixed by an HTML header and suffixed by an HTML footer.
Persisted to _State.description_ because of _StateDescriptionId.Set.featureName=description_.
+
.State Description Property Editor
image:images/descriptionProperty.png[]


.fowlerdsl.odesign
[source,subs="verbatim,quotes"]
----
platform:/resource/org.eclipse.xtext.example.fowlerdsl.viewpoint/description/fowlerdsl.odesign
	+ fowlerdsl
		+ Statemachine
			+ Statemachine Diagram
				+ Default
					+ *TransitionEdge*                        <2>
							id=TransitionEdge
							domainClass=statemachine.Transition
							labelDirectEdit=SelfEdit
						+ Edge Style solid
							+ *Center Label Style*
								labelExpression="ocl:self.event.name.concat( ' as Label')"
					+ EventsContainer
						+ *EventNode*                           <1>
								id=EventNode
								domainClass=statemachine.Event
								labelDirectEdit=SelfEdit
							+ *Square gray*
								labelExpression="ocl:self.name.concat(if(self.guard.oclIsUndefined()) then '' else ' [' + self.guard.toString() + ']' endif)"
					+ CommandsContainer
					+ StateNode
						+ *description*                         <3>
								id=description
								domainClass=statemachine.State
								labelDirectEdit=DescriptionEdit
							+ *square gray*
								labelExpression="ocl:'Desc: '.concat(self.description)"
					+ Section DefaultSection
						+ Direct Edit Label SimpleTextEdit
						+ *Direct Edit Label DescriptionEdit*   <3>
								inputLabelExpression="feature:description"
							+ Edit Mask Variables {0}
							+ Begin
								+ *Set description*
									featureName=description
						+ *Direct Edit Label SelfEdit*          <1><2>
								inputLabelExpression="var:self"
							+ Edit Mask Variables {0}
							+ Begin
								+ *Set*
									featureName=_«empty»_
			+ org.eclipse.xtext.example.fowlerdsl.viewpoint.Services
		+ Properties
			+ Default
				+ Default
					+ EventProperties
							domainClass=statemachine.Event
						+ Text
						+ *EventGuardId*                        <4>
								id=EventGuardId
								valueExpression="feature:guard"
							+ Begin
								+ *Set guard*
									featureName=guard
									valueExpression="var:newValue"
					+ StateProperties
							domainClass=statemachine.State
						+ Text
						+ *StateDescriptionId*                  <5>
								id=StateDescriptionId
								valueExpression="feature:description"
							+ Begin
								+ *Set description*
									featureName=description
									valueExpression="var:newValue"
platform:/resource/org.eclipse.xtext.example.fowlerdsl/model/generated/Statemachine.ecore
----

.Screenshot of fowlerdsl.odesign
image:images/exampleOdesign.png[]

== Reference

=== Editor Placement

[[directEdit]]
==== Diagram / Direct Editor

A direct editor is activated by

* double-clicking on the diagram element,
* pressing kbd:[F2] while the diagram element is focused,
* or starting to type while the diagram element is focused.

The editor replaces the label and is sized to fit its contents.

For single-line editors, the editor closes on pressing kbd:[Enter].

Editor contents are committed to the model when the editor is closed.
The editor closes when it loses focus, e.g. by a click outside the editor.


.Eclipse plugin.xml API

Direct editors are specified by the extension point `com.altran.general.integration.xtextsirius.xtextDirectEdit`.

.xtextDirectEdit.exsd (in digestible form)
[source,xml]
----
<extension point="com.altran.general.integration.xtextsirius.xtextDirectEdit">
	<!-- [0..*] model contents -->
	<xtextDirectEditModel
		configClass="«instance of com.altran.general.integration.xtextsirius.editpart.IXtextDirectEditConfiguration»"
		identifier="«Sirius element id»"
		multiLine="«true | false (default)»"
		edgeLabelPosition="«begin | center (default) | end»">
			<!-- [0..*] -->
			<editableFeature name="«feature name»"/>
	</xtextDirectEditModel>
	
	<!-- [0..*] value contents -->
	<xtextDirectEditValue
		configClass="«instance of com.altran.general.integration.xtextsirius.editpart.IXtextDirectEditConfiguration»"
		identifier="«Sirius element id»"
		multiLine="«true | false (default)»"
		prefixText="«text to pre-pend (optional)»"
		suffixText="«text to append (optional)»"/>
</extension>
----

One extension can contain several `xtextDirectEditModel` and/or `xtextDirectEditValue` elements.


.Java API

Direct editors require an instance of `IXtextDirectEditConfiguration` to provide the injector of the Xtext language to use.

.IXtextDirectEditConfiguration.java
[source,java]
----
package com.altran.general.integration.xtextsirius.editpart;

public interface IXtextDirectEditConfiguration {
	public @NonNull com.google.inject.Injector getInjector();
}
----


.Sirius element

Must fulfill the following criteria:

* unique id
* defined label
* defined direct label edit
* defined direct label edit set value operation

The label is independent of the edited text, i.e. the label can show a different text than the direct editor.

If the set value operation feature is empty, it is interpreted as to replace _var:self_.


.Capabilities

Direct editors 

* can contain <<model, model>> or <<value, value>> contents, 
* may display as <<singleLine-multiLine, single-line>> or <<singleLine-multiLine, multi-line>> editor, 
* and require an <<identifier, identifier>> and an <<injector, injector>>.

If the editor contains model contents, it supports to limit the <<editableFeatures, editable features>>.
If the model element is an edge, the editor requires an <<edgeLabelPosition, edgeLabelPosition>> (defaults to `center`).

[[property]]
==== Property View / Property Editor

The Eclipse Properties View contains the property editors.
The editor replaces the original widget.

Editor contents are committed when the editor is hidden.
This happens when the end-user selects a different property page or a different diagram element.


.Eclipse plugin.xml API

Property editors are specified by the extension point `com.altran.general.integration.xtextsirius.xtextProperty`.

.xtextProperty.exsd (in digestible form)
[source,xml]
----
<extension point="com.altran.general.integration.xtextsirius.xtextProperty">
	<!-- [0..*] model contents -->
	<xtextPropertyModel
		configClass="«instance of com.altran.general.integration.xtextsirius.eef.IXtextPropertyConfiguration»"
		identifier="«Sirius element id»"
		multiLine="«true | false (default)»"/>
	
	<!-- [0..*] value contents -->
	<xtextPropertyValue
		configClass="«instance of com.altran.general.integration.xtextsirius.eef.IXtextPropertyConfiguration»"
		identifier="«Sirius element id»"
		multiLine="«true | false (default)»"
		prefixText="«text to pre-pend (optional)»"
		suffixText="«text to append (optional)»"/>
</extension>
----

One extension can contain several `xtextPropertyModel` and/or `xtextPropertyValue` elements.


.Java API

Direct editors require an instance of `IXtextPropertyConfiguration` to provide the injector of the Xtext language to use.
The configuration also allows to customize <<widget, SWT widget style>> and <<layoutData, SWT Grid Layout Data>>.

.IXtextPropertyConfiguration.java
[source,java]
----
package com.altran.general.integration.xtextsirius.eef;

public interface IXtextPropertyConfiguration {
	public @NonNull com.google.inject.Injector getInjector();
	
	int getSwtWidgetStyle(int defaultStyle);
	
	public @NonNull org.eclipse.swt.layout.GridData getLayoutData(final @NonNull org.eclipse.swt.layout.GridData defaultData);
}
----

The abstract class `com.altran.general.integration.xtextsirius.eef.AXtextPropertyConfiguration` provides a default implementation for
`getSwtWidgetStyle()` and `getLayoutData()`.


.Sirius element

Must fulfill the following criteria:

* Text or TextArea widget
* unique id
* defined valueExpression
* defined set value operation


.Capabilities

Property editors

* can contain <<model, model>> or <<value, value>> contents, 
* may display as <<singleLine-multiLine, single-line>> or <<singleLine-multiLine, multi-line>> editor, 
* require an <<identifier, identifier>> and an <<injector, injector>>,
* and can customize the <<widgetStyle, widgetStyle>> and/or <<layoutData, layoutData>>.


[[widgetStyle]]
===== SWT Widget Style

<<property, Property editors>> allow the customization of their SWT Widget Style.

The method `int com.altran.general.integration.xtextsirius.eef.IXtextPropertyConfiguration.getSwtWidgetStyle(final int defaultStyle)`
receives the default style (determined by several factors, including single-line vs. multi-line), and may modify it.
The method's result is used as widget style.

The default implementation in `com.altran.general.integration.xtextsirius.eef.AXtextPropertyConfiguration` does not modify the style.


[[layoutData]]
===== SWT GridLayoutData

<<property, Property editors>> allow the customization of their SWT Grid Layout Data.

The method `@NonNull org.eclipse.swt.layout.GridData com.altran.general.integration.xtextsirius.eef.AXtextPropertyConfiguration.getLayoutData(final @NonNull org.eclipse.swt.layout.GridData defaultData)`
receives the default GridLayoutData, and may modify it.
The method's result is used as the widget's layout data.

The default implementation in `com.altran.general.integration.xtextsirius.eef.AXtextPropertyConfiguration` does not modify the grid layout data.


=== Editor Contents

[[model]]
==== Editing Models

The editor can contain semantic elements from the same model the edited diagram is based on.

A typical use-case may allow the end-user to edit several features of a semantic element in-line with complete Xtext support.

.Example

As an example, think of a UML class attribute displayed as "``+ age: int = 0``".
If the end-user opens the direct editor of the attribute, they can change all these features (visibility, name, type, default value) with complete Xtext support, e.g.

* Proposing all possible visibilities
* Validating the name (e.g. do not allow spaces)
* Proposing and checking the available types
* Allow no, a literal, or a referenced default value

.Details

The editor assumes the model of the edited diagram is persisted with the same Xtext grammar as supplied to the editor (except for <<specialEditGrammar, explicit differences>>).

Any changes in the editor are applied to the underlying model of the edited diagram.
The changes are committed to the Sirius edit session, but only persisted if and when the edited diagram is saved.

The editor maintains references between the edited semantic element (and its descendants) and the rest of the model in both directions, if possible.
The editor does not prevent the end-user from breaking references, e.g. by changed referenced names or deleting referenced elements.

In order to provide appropriate auto-completion and other Xtext features, the editor maintains a complete copy of the edited diagram's model.
However, only the subsection relevant to the selected semantic element (and limited by the <<editableFeatures, editable features>>, if applicable) is shown to, and editable by, the end-user.

Determining the correct subsection is quite complicated, especially if the subsection borders in grammar terminals or contains unset features.
This may lead to incorrectly selected subsections. However, the result should only be affected by the grammar, therefore the developer can test this during development.

The editor reintegrates its contents into the edited diagram's model on model level, not on text level.
This means if the end-user modified any part of the model not contained within the edited semantic element, these changes are not committed.


[[value]]
==== Editing Values

The editor can interpret simple String features of semantic elements as Xtext models.

A typical use-case may allow the end-user to edit the description feature of a semantic element as markup text with complete Xtext support.

.Example

As an example, think of an entity model containing classes that may have descriptions. By its metamodel, the description is merely a String.
An Xtext value editor (primed with an Xtext implementation of HTML) for the description allows the end-user to describe the class with complete Xtext support for HTML.

.Details

Any changes in the editor are stored in the semantic element's String feature as-is.
The changes are committed to the Sirius edit session, but only persisted if and when the edited diagram is saved.


[[prefixText-suffixText]]
===== PrefixText and SuffixText

In order to provide appropriate auto-completion and other Xtext features, the editor requires a complete model.
However, the String feature may contain only a subsection of a complete model.
Therefore, the developer may provide text that should be pre-pended and appended to the String feature's value in order to complete the model.
The end-user still sees and edits only the String feature's value.

.Example

Think of a simplified version of HTML implemented as Xtext language. A complete model might look like this:

[source, html]
----
<html>
<head>
	<title>This is a test</title>
</head>
<body>
	<p>Some paragraph</p>
	<ul>
		<li>This is <b>important</b></li>
		<li>And something's <i>useful</i></li>
	</ul>
	<p>Some other not so <i>very interesting,</i> but yet <b>highlighted</b> paragraph</p>
</body>
</html>
----

This language should be used for the description feature of classes in an entity model.

However, the model may contain several such classes, and the description of all of them should end up in only one HTML file (in a later generation step).
Instead of storing a complete model into every class' description (and bothering the end-user with it), only the description contains only the following part:

[source, html]
----
	<p>Some paragraph</p>
	<ul>
		<li>This is <b>important</b></li>
		<li>And something's <i>useful</i></li>
	</ul>
	<p>Some other not so <i>very interesting,</i> but yet <b>highlighted</b> paragraph</p>
----

In order to complete the model for Xtext, the developer supplies the editor with

prefixText::
	`<html><head><title>Title</title><head><body>`
suffixText::
	`</body></html>`

This way, Xtext works on a complete model, but only the relevant parts are available to the end-user.



=== Editor Infos footnoteref:[info,	These are actually properties of the editor -- but this term is already used a lot.]

[[identifier]]
==== Identifier

An identifier links between the entry in `plugin.xml` and the Sirius element.

The identifier must be unique within the whole Sirius application.

The identifier is compared case-sensitive.


[[injector]]
==== Injector

An injector describes a complete Xtext configuration for a language.

The editor relies heavily on the instances provided by the injector. Incomplete configurations will lead to all kind of strange effects.


[[singleLine-multiLine]]
==== Single-line vs. Multi-line

The editor can display one single line or several lines.

Effects for single-line editors:

* All newline characters from the original content are replaced by the same amount of spaces.
* It is not possible to enter a newline.
* kbd:[Enter] closes the direct editor.


[[editableFeatures]]
==== Editable Features

The editor can limit which features of a semantic element are editable by the end-user.

A typical use-case hides the feature defining the source and/or target of an edge from being edited textually.


.Example

Assume the following Xtext grammar snippet defining an UML-like Association, to be displayed as edge:

[source, antlr]
----
Association:
	name=ID
	code=INT?
	('[' guard=Guard ']')?
	source=[Class] '-->' target=[Class]
;
----

Example model:
----
	driver 23 Car --> Person
----

The label would show `driver 23`.

The end-user should not be able to change the source and/or target of the association, but use an Xtext editor for the label to edit the other features.

Therefore, the developer supplies the following list of `editableFeatures`:

* `name`
* `code`
* `guard`


.Limitations

Limiting the editable features works by finding the first and last of the features in the text stream, and limit the editable area of the model to this subpart.

Therefore, if the model looks like
----
	driver 23 [someCondition] Car --> Person
----

and the `editableFeatures` are limited to

* `name`
* `guard`

the editor would _still_ include the `code` subpart, because it's in between the `name` and `guard` subpart.
----
	driver 23 [someCondition]
----


[[edgeLabelPosition]]
==== Position of Affected Edge Label

Unfortunately, the Sirius _odesign_ model does not contain identifiers for the different edge labels (`begin`, `center`, `end`).

Therefore, if the developer attaches a direct editor to an edge, the developer needs to specify which edge label should be equipped with Xtext powers.
Per default, the `center` label is selected.


[[specialEditGrammar]]
== Using a Different Grammar for Editing Model Contents

For editing model contents, we might use a grammar that differs from the one used for model serialization.

A typical use-case may allow to change the order of features in order to allow only a subset of them to be modified.

.Example

As an example, assume the following Xtext grammar snippet:
[source, antlr]
----
grammar org.eclipse.xtext.example.fowlerdsl.Statemachine with org.eclipse.xtext.common.Terminals

generate statemachine "http://www.eclipse.org/xtext/example/fowlerdsl/Statemachine"

Statemachine :
     {Statemachine}
	('events' 
		events+=Event+ 
	'end')?

	// ...
;

Event:
	name=ID code=INT? ('[' guard=Guard ']')?
;

// ...

----

In our editor, we want the end-user to edit only the `name` and `guard` features of `Event`. This is not possible with the given grammar, as `code` is placed between them.

To solve this, we create a new language:
[source, antlr]
----
grammar org.eclipse.xtext.example.fowlerdsl.InlineEdit with org.eclipse.xtext.example.fowlerdsl.Statemachine

import "http://www.eclipse.org/xtext/example/fowlerdsl/Statemachine" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

InlineStatemachine returns Statemachine:   <1>
	Statemachine
;

//@Override 
Event:                                     <2>
	name=ID ('[' guard=Guard ']')? code=INT?
;

----
<1> We have to have a root rule, because Xtext uses the first rule as entry rule. We just forward to the original root rule.
<2> Newer Xtext version know the `@Override` annotation to redefine a rule.

This creates a grammar (for the identical metamodel) that serializes features `name` and `guard` adjacent to each other, so we can limit the editor to them.


.Details

The editing grammar must fulfill the following criteria:

* based on identical metamodel
* has same root element
* contains rules for all semantic elements also covered by the original grammar (either inherited or self-implemented)
* must serialize correctly from a model without any previous textual representation

.Fixing serialization issues

If you experience serialization issues, namely keywords get merged resulting in invalid syntax, you can use a workaround provided by this plugin.

Typical symptoms of this issue include invalid auto-completion suggestions in the editor and exceptions on committing the changed elements.

To fix this, register the following classes to the editing language:

[source, java]
----
public class InlineEditRuntimeModule extends org.eclipse.xtext.example.fowlerdsl.AbstractInlineEditRuntimeModule {

	public Class<? extends IHiddenTokenSequencer> bindIHiddenTokenSequencer() {
		return com.altran.general.integration.xtextsirius.serializer.ForceWhitespaceBetweenKeywordsHiddenTokenSequencer.class;
	}

	public Class<? extends TextRegionAccessBuilder> bindTextRegionAccessBuilder() {
		return com.altran.general.integration.xtextsirius.serializer.ForceWhitespaceBetweenKeywordsTextRegionAccessBuilder.class;
	}
	
}
----



== Known Issues

* Determining the correct subsection for <<model, model content>> is not always possible.
* Validation errors (especially syntax errors) are not handled.
