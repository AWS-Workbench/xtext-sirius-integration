/*
 * generated by Xtext 2.9.1
 */
package nl.altran.example.xtext.html.serializer;

import com.google.inject.Inject;
import java.util.Set;
import nl.altran.example.xtext.html.htmlLang.Body;
import nl.altran.example.xtext.html.htmlLang.Bold;
import nl.altran.example.xtext.html.htmlLang.FreeformText;
import nl.altran.example.xtext.html.htmlLang.Head;
import nl.altran.example.xtext.html.htmlLang.Html;
import nl.altran.example.xtext.html.htmlLang.HtmlLangPackage;
import nl.altran.example.xtext.html.htmlLang.Italics;
import nl.altran.example.xtext.html.htmlLang.ListItem;
import nl.altran.example.xtext.html.htmlLang.Paragraph;
import nl.altran.example.xtext.html.htmlLang.Style;
import nl.altran.example.xtext.html.htmlLang.Title;
import nl.altran.example.xtext.html.htmlLang.UnorderedList;
import nl.altran.example.xtext.html.services.HtmlLangGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class HtmlLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private HtmlLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == HtmlLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case HtmlLangPackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case HtmlLangPackage.BOLD:
				sequence_Bold(context, (Bold) semanticObject); 
				return; 
			case HtmlLangPackage.FREEFORM_TEXT:
				sequence_FreeformText(context, (FreeformText) semanticObject); 
				return; 
			case HtmlLangPackage.HEAD:
				sequence_Head(context, (Head) semanticObject); 
				return; 
			case HtmlLangPackage.HTML:
				sequence_Html(context, (Html) semanticObject); 
				return; 
			case HtmlLangPackage.ITALICS:
				sequence_Italics(context, (Italics) semanticObject); 
				return; 
			case HtmlLangPackage.LIST_ITEM:
				sequence_ListItem(context, (ListItem) semanticObject); 
				return; 
			case HtmlLangPackage.PARAGRAPH:
				sequence_Paragraph(context, (Paragraph) semanticObject); 
				return; 
			case HtmlLangPackage.STYLE:
				sequence_Style(context, (Style) semanticObject); 
				return; 
			case HtmlLangPackage.TITLE:
				sequence_Title(context, (Title) semanticObject); 
				return; 
			case HtmlLangPackage.UNORDERED_LIST:
				sequence_UnorderedList(context, (UnorderedList) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Body returns Body
	 *
	 * Constraint:
	 *     contents+=BodyContents*
	 */
	protected void sequence_Body(ISerializationContext context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextElement returns Bold
	 *     Bold returns Bold
	 *
	 * Constraint:
	 *     text=HTMLSTRING
	 */
	protected void sequence_Bold(ISerializationContext context, Bold semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoldAccess().getTextHTMLSTRINGTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TextElement returns FreeformText
	 *     FreeformText returns FreeformText
	 *
	 * Constraint:
	 *     text=HTMLSTRING
	 */
	protected void sequence_FreeformText(ISerializationContext context, FreeformText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFreeformTextAccess().getTextHTMLSTRINGTerminalRuleCall_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Head returns Head
	 *
	 * Constraint:
	 *     headers+=Header*
	 */
	protected void sequence_Head(ISerializationContext context, Head semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Html returns Html
	 *
	 * Constraint:
	 *     (head=Head body=Body)
	 */
	protected void sequence_Html(ISerializationContext context, Html semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HtmlLangPackage.Literals.HTML__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HtmlLangPackage.Literals.HTML__HEAD));
			if (transientValues.isValueTransient(semanticObject, HtmlLangPackage.Literals.HTML__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HtmlLangPackage.Literals.HTML__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHtmlAccess().getHeadHeadParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getHtmlAccess().getBodyBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TextElement returns Italics
	 *     Italics returns Italics
	 *
	 * Constraint:
	 *     text=HTMLSTRING
	 */
	protected void sequence_Italics(ISerializationContext context, Italics semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getItalicsAccess().getTextHTMLSTRINGTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListItem returns ListItem
	 *
	 * Constraint:
	 *     contents+=TextElement*
	 */
	protected void sequence_ListItem(ISerializationContext context, ListItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyContents returns Paragraph
	 *     Paragraph returns Paragraph
	 *
	 * Constraint:
	 *     contents+=TextElement*
	 */
	protected void sequence_Paragraph(ISerializationContext context, Paragraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Header returns Style
	 *     Style returns Style
	 *
	 * Constraint:
	 *     styles=HTMLSTRING
	 */
	protected void sequence_Style(ISerializationContext context, Style semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HtmlLangPackage.Literals.STYLE__STYLES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HtmlLangPackage.Literals.STYLE__STYLES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStyleAccess().getStylesHTMLSTRINGTerminalRuleCall_1_0(), semanticObject.getStyles());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Header returns Title
	 *     Title returns Title
	 *
	 * Constraint:
	 *     name=HTMLSTRING
	 */
	protected void sequence_Title(ISerializationContext context, Title semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HtmlLangPackage.Literals.TITLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HtmlLangPackage.Literals.TITLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTitleAccess().getNameHTMLSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BodyContents returns UnorderedList
	 *     UnorderedList returns UnorderedList
	 *
	 * Constraint:
	 *     items+=ListItem+
	 */
	protected void sequence_UnorderedList(ISerializationContext context, UnorderedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
