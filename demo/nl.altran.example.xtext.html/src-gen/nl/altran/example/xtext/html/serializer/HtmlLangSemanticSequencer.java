/*
 * generated by Xtext 2.12.0
 */
package nl.altran.example.xtext.html.serializer;

import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

import com.google.inject.Inject;

import nl.altran.example.xtext.html.htmlLang.Body;
import nl.altran.example.xtext.html.htmlLang.Bold;
import nl.altran.example.xtext.html.htmlLang.FreeformText;
import nl.altran.example.xtext.html.htmlLang.Head;
import nl.altran.example.xtext.html.htmlLang.Html;
import nl.altran.example.xtext.html.htmlLang.HtmlLangPackage;
import nl.altran.example.xtext.html.htmlLang.Italics;
import nl.altran.example.xtext.html.htmlLang.ListItem;
import nl.altran.example.xtext.html.htmlLang.Paragraph;
import nl.altran.example.xtext.html.htmlLang.Style;
import nl.altran.example.xtext.html.htmlLang.Title;
import nl.altran.example.xtext.html.htmlLang.UnorderedList;
import nl.altran.example.xtext.html.services.HtmlLangGrammarAccess;

@SuppressWarnings("all")
public class HtmlLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {
	
	@Inject
	private HtmlLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(final ISerializationContext context, final EObject semanticObject) {
		final EPackage epackage = semanticObject.eClass().getEPackage();
		final ParserRule rule = context.getParserRule();
		final Action action = context.getAssignedAction();
		final Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == HtmlLangPackage.eINSTANCE) {
			switch (semanticObject.eClass().getClassifierID()) {
				case HtmlLangPackage.BODY:
					sequence_Body(context, (Body) semanticObject);
					return;
				case HtmlLangPackage.BOLD:
					sequence_Bold(context, (Bold) semanticObject);
					return;
				case HtmlLangPackage.FREEFORM_TEXT:
					sequence_FreeformText(context, (FreeformText) semanticObject);
					return;
				case HtmlLangPackage.HEAD:
					sequence_Head(context, (Head) semanticObject);
					return;
				case HtmlLangPackage.HTML:
					sequence_Html(context, (Html) semanticObject);
					return;
				case HtmlLangPackage.ITALICS:
					sequence_Italics(context, (Italics) semanticObject);
					return;
				case HtmlLangPackage.LIST_ITEM:
					sequence_ListItem(context, (ListItem) semanticObject);
					return;
				case HtmlLangPackage.PARAGRAPH:
					sequence_Paragraph(context, (Paragraph) semanticObject);
					return;
				case HtmlLangPackage.STYLE:
					sequence_Style(context, (Style) semanticObject);
					return;
				case HtmlLangPackage.TITLE:
					sequence_Title(context, (Title) semanticObject);
					return;
				case HtmlLangPackage.UNORDERED_LIST:
					sequence_UnorderedList(context, (UnorderedList) semanticObject);
					return;
			}
		}
		if (this.errorAcceptor != null) {
			this.errorAcceptor
					.accept(this.diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
		}
	}
	
	/**
	 * Contexts: Body returns Body
	 *
	 * Constraint: contents+=BodyContents*
	 */
	protected void sequence_Body(final ISerializationContext context, final Body semanticObject) {
		this.genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts: TextElement returns Bold Bold returns Bold
	 *
	 * Constraint: text=HTMLSTRING
	 */
	protected void sequence_Bold(final ISerializationContext context, final Bold semanticObject) {
		if (this.errorAcceptor != null) {
			if (this.transientValues.isValueTransient(semanticObject,
					HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT) == ValueTransient.YES) {
				this.errorAcceptor.accept(this.diagnosticProvider.createFeatureValueMissing(semanticObject,
						HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT));
			}
		}
		final SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(this.grammarAccess.getBoldAccess().getTextHTMLSTRINGTerminalRuleCall_1_0(),
				semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts: TextElement returns FreeformText FreeformText returns
	 * FreeformText
	 *
	 * Constraint: text=HTMLSTRING
	 */
	protected void sequence_FreeformText(final ISerializationContext context, final FreeformText semanticObject) {
		if (this.errorAcceptor != null) {
			if (this.transientValues.isValueTransient(semanticObject,
					HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT) == ValueTransient.YES) {
				this.errorAcceptor.accept(this.diagnosticProvider.createFeatureValueMissing(semanticObject,
						HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT));
			}
		}
		final SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(this.grammarAccess.getFreeformTextAccess().getTextHTMLSTRINGTerminalRuleCall_0(),
				semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts: Head returns Head
	 *
	 * Constraint: headers+=Header*
	 */
	protected void sequence_Head(final ISerializationContext context, final Head semanticObject) {
		this.genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts: Html returns Html
	 *
	 * Constraint: (head=Head body=Body)
	 */
	protected void sequence_Html(final ISerializationContext context, final Html semanticObject) {
		if (this.errorAcceptor != null) {
			if (this.transientValues.isValueTransient(semanticObject,
					HtmlLangPackage.Literals.HTML__HEAD) == ValueTransient.YES) {
				this.errorAcceptor.accept(this.diagnosticProvider.createFeatureValueMissing(semanticObject,
						HtmlLangPackage.Literals.HTML__HEAD));
			}
			if (this.transientValues.isValueTransient(semanticObject,
					HtmlLangPackage.Literals.HTML__BODY) == ValueTransient.YES) {
				this.errorAcceptor.accept(this.diagnosticProvider.createFeatureValueMissing(semanticObject,
						HtmlLangPackage.Literals.HTML__BODY));
			}
		}
		final SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(this.grammarAccess.getHtmlAccess().getHeadHeadParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(this.grammarAccess.getHtmlAccess().getBodyBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts: TextElement returns Italics Italics returns Italics
	 *
	 * Constraint: text=HTMLSTRING
	 */
	protected void sequence_Italics(final ISerializationContext context, final Italics semanticObject) {
		if (this.errorAcceptor != null) {
			if (this.transientValues.isValueTransient(semanticObject,
					HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT) == ValueTransient.YES) {
				this.errorAcceptor.accept(this.diagnosticProvider.createFeatureValueMissing(semanticObject,
						HtmlLangPackage.Literals.TEXT_ELEMENT__TEXT));
			}
		}
		final SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(this.grammarAccess.getItalicsAccess().getTextHTMLSTRINGTerminalRuleCall_1_0(),
				semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts: ListItem returns ListItem
	 *
	 * Constraint: contents+=TextElement*
	 */
	protected void sequence_ListItem(final ISerializationContext context, final ListItem semanticObject) {
		this.genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts: BodyContents returns Paragraph Paragraph returns Paragraph
	 *
	 * Constraint: contents+=TextElement*
	 */
	protected void sequence_Paragraph(final ISerializationContext context, final Paragraph semanticObject) {
		this.genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts: Header returns Style Style returns Style
	 *
	 * Constraint: styles=HTMLSTRING
	 */
	protected void sequence_Style(final ISerializationContext context, final Style semanticObject) {
		if (this.errorAcceptor != null) {
			if (this.transientValues.isValueTransient(semanticObject,
					HtmlLangPackage.Literals.STYLE__STYLES) == ValueTransient.YES) {
				this.errorAcceptor.accept(this.diagnosticProvider.createFeatureValueMissing(semanticObject,
						HtmlLangPackage.Literals.STYLE__STYLES));
			}
		}
		final SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(this.grammarAccess.getStyleAccess().getStylesHTMLSTRINGTerminalRuleCall_1_0(),
				semanticObject.getStyles());
		feeder.finish();
	}
	
	
	/**
	 * Contexts: Header returns Title Title returns Title
	 *
	 * Constraint: name=HTMLSTRING
	 */
	protected void sequence_Title(final ISerializationContext context, final Title semanticObject) {
		if (this.errorAcceptor != null) {
			if (this.transientValues.isValueTransient(semanticObject,
					HtmlLangPackage.Literals.TITLE__NAME) == ValueTransient.YES) {
				this.errorAcceptor.accept(this.diagnosticProvider.createFeatureValueMissing(semanticObject,
						HtmlLangPackage.Literals.TITLE__NAME));
			}
		}
		final SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(this.grammarAccess.getTitleAccess().getNameHTMLSTRINGTerminalRuleCall_1_0(),
				semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts: BodyContents returns UnorderedList UnorderedList returns
	 * UnorderedList
	 *
	 * Constraint: items+=ListItem+
	 */
	protected void sequence_UnorderedList(final ISerializationContext context, final UnorderedList semanticObject) {
		this.genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
